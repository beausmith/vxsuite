import { promises as fs } from 'fs';
import { sha256 } from 'js-sha256';
import { parse, relative } from 'path';
import { isImageMimeType, isTextMimeType } from './mime';

/**
 * A resource to be converted.
 */
export interface Resource {
  readonly path: string;
  readonly tsPath: string;
  readonly mimeType: string;
}

/**
 * Converts a resource to be readable as a TypeScript file.
 */
export async function convert({ path, mimeType }: Resource): Promise<string> {
  const pathParts = parse(path);
  const relativePath = relative(process.cwd(), path);
  const isImageResource = isImageMimeType(mimeType);
  const isTextResource = isTextMimeType(mimeType);
  const isElectionDefinition =
    pathParts.ext === '.json' && pathParts.name.startsWith('election');
  const resourceData = await fs.readFile(path);
  const lines: string[] = [
    `/* Generated by res-to-ts. DO NOT EDIT */`,
    `/* eslint-disable */`,
    `/* istanbul ignore file */`,
    ``,
    `import { Buffer } from 'buffer';`,
  ];

  if (isImageResource) {
    lines.push(
      `import { createCanvas, Image, ImageData, loadImage } from 'canvas';`,
      ``
    );
  }

  if (isElectionDefinition) {
    lines.push(
      `import { safeParseElectionDefinition } from '@votingworks/types';`
    );
  }

  const hash = sha256(resourceData);

  lines.push(
    ``,
    `/**`,
    ` * Data of ${relativePath} encoded as base64.`,
    ` *`,
    ` * SHA-256 hash of file data: ${hash}`,
    ` */`,
    `const resourceDataBase64 = '${resourceData.toString('base64')}';`,
    ``,
    `/**`,
    ` * MIME type of ${relativePath}.`,
    ` */`,
    `export const mimeType = '${mimeType}';`,
    ``,
    `/**`,
    ` * Convert to a \`data:\` URL of ${relativePath}, suitable for embedding in HTML.`,
    ` *`,
    ` * SHA-256 hash of file data: ${hash}`,
    ` */`,
    `export function asDataUrl() {`,
    `  return \`data:\${mimeType};base64,\${resourceDataBase64}\`;`,
    `}`,
    ``,
    `/**`,
    ` * Raw data of ${relativePath}.`,
    ` *`,
    ` * SHA-256 hash of file data: ${hash}`,
    ` */`,
    `export function asBuffer(): Buffer {`,
    `  return Buffer.from(resourceDataBase64, 'base64');`,
    `}`
  );

  if (isTextResource) {
    lines.push(
      ``,
      `/**`,
      ` * Text content of ${relativePath}.`,
      ` *`,
      ` * SHA-256 hash of file data: ${hash}`,
      ` */`,
      `export function asText(): string {`,
      `  return asBuffer().toString('utf-8');`,
      `}`
    );
  }

  if (isImageResource) {
    lines.push(
      ``,
      `/**`,
      ` * Converts ${relativePath} to an \`Image\`.`,
      ` *`,
      ` * SHA-256 hash of file data: ${hash}`,
      ` */`,
      `export async function asImage(): Promise<Image> {`,
      // Use `loadImage` with a data URL because `Buffer` only works in NodeJS.
      `  return await loadImage(asDataUrl());`,
      `}`,
      ``,
      `/**`,
      ` * Converts ${relativePath} to an \`ImageData\`.`,
      ` *`,
      ` * SHA-256 hash of file data: ${hash}`,
      ` */`,
      `export async function asImageData(): Promise<ImageData> {`,
      `  const image = await asImage();`,
      `  const canvas = createCanvas(image.width, image.height);`,
      `  const context = canvas.getContext('2d');`,
      `  context.drawImage(image, 0, 0);`,
      `  return context.getImageData(0, 0, image.width, image.height);`,
      `}`
    );
  }

  if (isElectionDefinition) {
    lines.push(
      ``,
      `/**`,
      ` * Full election definition for ${relativePath}.`,
      ` *`,
      ` * SHA-256 hash of file data: ${hash}`,
      ` */`,
      `export const electionDefinition = safeParseElectionDefinition(`,
      `  asText()`,
      `).unsafeUnwrap();`,
      ``,
      `/**`,
      ` * Election definition for ${relativePath}.`,
      ` *`,
      ` * SHA-256 hash of file data: ${hash}`,
      ` */`,
      `export const election = electionDefinition.election;`
    );
  }

  return lines.join('\n');
}
