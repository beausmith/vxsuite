import {
  AdminCardData,
  AnyCardDataSchema,
  CardProgramming,
  CardStorage,
  DippedSmartcardAuth,
  err,
  InsertedSmartcardAuth,
  ok,
  Optional,
  PollworkerCardData,
  safeParseJson,
  SuperadminCardData,
  User,
  wrapException,
} from '@votingworks/types';
import { Card, CardSummaryReady, throwIllegalValue } from '@votingworks/utils';
import { LogEventId, Logger } from '@votingworks/logging';

import { Lock } from '../use_lock';

export const CARD_POLLING_INTERVAL = 100;

export function parseUserFromCardSummary(
  cardSummary: CardSummaryReady
): Optional<User> {
  if (!cardSummary.shortValue) return undefined;
  const cardData = safeParseJson(
    cardSummary.shortValue,
    AnyCardDataSchema
  ).ok();
  if (!cardData) return undefined;
  switch (cardData.t) {
    case 'superadmin':
      return { role: 'superadmin' };
    case 'admin':
      return { role: 'admin', electionHash: cardData.h, passcode: cardData.p };
    case 'pollworker':
      return { role: 'pollworker', electionHash: cardData.h };
    case 'voter':
      return {
        role: 'voter',
        createdAt: cardData.c,
        ballotStyleId: cardData.bs,
        precinctId: cardData.pr,
        voidedAt: cardData.uz,
        ballotPrintedAt: cardData.bp,
        updatedAt: cardData.u,
        markMachineId: cardData.m,
      };
    /* istanbul ignore next - compile time check for completeness */
    default:
      throwIllegalValue(cardData, 't');
  }
}

export function buildCardStorage(
  cardSummary: CardSummaryReady,
  cardApi: Card,
  cardWriteLock: Lock
): CardStorage {
  return {
    hasStoredData: !!cardSummary.longValueExists,

    readStoredObject: async (schema) => cardApi.readLongObject(schema),

    readStoredString: async () => {
      try {
        const value = await cardApi.readLongString();
        return ok(value || undefined);
      } catch (error) {
        return wrapException(error);
      }
    },

    readStoredUint8Array: async () => {
      try {
        const value = await cardApi.readLongUint8Array();
        return ok(value && value.length > 0 ? value : undefined);
      } catch (error) {
        return wrapException(error);
      }
    },

    writeStoredData: async (value) => {
      if (!cardWriteLock.lock()) {
        return err(new Error('Card write in progress'));
      }
      try {
        if (value instanceof Uint8Array) {
          await cardApi.writeLongUint8Array(value);
        } else {
          await cardApi.writeLongObject(value);
        }
        return ok();
      } catch (error) {
        return wrapException(error);
      } finally {
        cardWriteLock.unlock();
      }
    },

    clearStoredData: async () => {
      if (!cardWriteLock.lock()) {
        return err(new Error('Card write in progress'));
      }
      try {
        await cardApi.writeLongUint8Array(Uint8Array.of());
        return ok();
      } catch (error) {
        return wrapException(error);
      } finally {
        cardWriteLock.unlock();
      }
    },
  };
}

/**
 * Builds an interface for smartcard programming, meant to augment the base smartcard interface
 * generated by buildCardStorage
 */
export function buildCardProgramming(
  cardSummary: CardSummaryReady,
  cardApi: Card,
  cardWriteLock: Lock,
  logger?: Logger
): CardProgramming {
  const programmedUser = parseUserFromCardSummary(cardSummary);

  const programUser: CardProgramming['programUser'] = async (userData) => {
    const { role } = userData;
    try {
      if (!cardWriteLock.lock()) {
        throw new Error('Card write in progress');
      }
      switch (role) {
        case 'superadmin': {
          const cardData: SuperadminCardData = {
            t: 'superadmin',
          };
          await cardApi.overrideWriteProtection();
          await cardApi.writeShortValue(JSON.stringify(cardData));
          break;
        }
        case 'admin': {
          const cardData: AdminCardData = {
            t: 'admin',
            h: userData.electionHash,
            p: userData.passcode,
          };
          await cardApi.overrideWriteProtection();
          await cardApi.writeShortAndLongValues({
            shortValue: JSON.stringify(cardData),
            longValue: userData.electionData,
          });
          break;
        }
        case 'pollworker': {
          const cardData: PollworkerCardData = {
            t: 'pollworker',
            h: userData.electionHash,
          };
          await cardApi.overrideWriteProtection();
          await cardApi.writeShortValue(JSON.stringify(cardData));
          break;
        }
        /* istanbul ignore next: Compile-time check for completeness */
        default:
          throwIllegalValue(role);
      }
      return ok();
    } catch (error) {
      return wrapException(error);
    } finally {
      cardWriteLock.unlock();
    }
  };

  const unprogramUser: CardProgramming['unprogramUser'] = async () => {
    if (!programmedUser) {
      // Short-circuit if the card is already unprogrammed
      return ok();
    }
    try {
      if (!cardWriteLock.lock()) {
        throw new Error('Card write in progress');
      }
      await cardApi.overrideWriteProtection();
      await cardApi.writeShortAndLongValues({
        shortValue: '',
        longValue: '',
      });
      return ok();
    } catch (error) {
      return wrapException(error);
    } finally {
      cardWriteLock.unlock();
    }
  };

  return {
    programmedUser,

    programUser: async (userData) => {
      if (!logger) {
        return await programUser(userData);
      }

      const { role } = userData;
      await logger.log(LogEventId.SmartcardProgramInit, 'superadmin', {
        message: `Programming ${role} smartcard...`,
        programmedUserRole: role,
      });
      const result = await programUser(userData);
      await logger.log(LogEventId.SmartcardProgramComplete, 'superadmin', {
        disposition: result.isOk() ? 'success' : 'failure',
        message: result.isOk()
          ? `Successfully programmed ${role} smartcard.`
          : `Error programming ${role} smartcard.`,
        programmedUserRole: role,
      });
      return result;
    },

    unprogramUser: async () => {
      if (!logger) {
        return await unprogramUser();
      }

      const programmedUserRole = programmedUser?.role || 'unprogrammed';
      await logger.log(LogEventId.SmartcardUnprogramInit, 'superadmin', {
        message: `Unprogramming ${programmedUserRole} smartcard...`,
        programmedUserRole,
      });
      const result = await unprogramUser();
      if (result.isOk()) {
        await logger.log(LogEventId.SmartcardUnprogramComplete, 'superadmin', {
          disposition: 'success',
          message:
            programmedUserRole === 'unprogrammed'
              ? 'Smartcard already unprogrammed (no-op).'
              : `Successfully unprogrammed ${programmedUserRole} smartcard.`,
          previousProgrammedUserRole: programmedUserRole,
        });
      } else {
        await logger.log(LogEventId.SmartcardUnprogramComplete, 'superadmin', {
          disposition: 'failure',
          message: `Error unprogramming ${programmedUserRole} smartcard.`,
          programmedUserRole,
        });
      }
      return result;
    },
  };
}

// Below, we define some useful type guards for checking who's logged in
// We use function overloads to make them work with either Inserted or Dipped auth

export function isSuperadminAuth(
  auth: InsertedSmartcardAuth.Auth
): auth is InsertedSmartcardAuth.SuperadminLoggedIn;
export function isSuperadminAuth(
  auth: DippedSmartcardAuth.Auth
): auth is DippedSmartcardAuth.SuperadminLoggedIn;
export function isSuperadminAuth(
  auth: InsertedSmartcardAuth.Auth | DippedSmartcardAuth.Auth
): boolean {
  return auth.status === 'logged_in' && auth.user.role === 'superadmin';
}

export function isAdminAuth(
  auth: InsertedSmartcardAuth.Auth
): auth is InsertedSmartcardAuth.AdminLoggedIn;
export function isAdminAuth(
  auth: DippedSmartcardAuth.Auth
): auth is DippedSmartcardAuth.AdminLoggedIn;
export function isAdminAuth(
  auth: InsertedSmartcardAuth.Auth | DippedSmartcardAuth.Auth
): boolean {
  return auth.status === 'logged_in' && auth.user.role === 'admin';
}

export function isPollworkerAuth(
  auth: InsertedSmartcardAuth.Auth
): auth is InsertedSmartcardAuth.PollworkerLoggedIn {
  return auth.status === 'logged_in' && auth.user.role === 'pollworker';
}

export function isVoterAuth(
  auth: InsertedSmartcardAuth.Auth
): auth is InsertedSmartcardAuth.VoterLoggedIn {
  return auth.status === 'logged_in' && auth.user.role === 'voter';
}

export function isCardlessVoterAuth(
  auth: InsertedSmartcardAuth.Auth
): auth is InsertedSmartcardAuth.CardlessVoterLoggedIn {
  return auth.status === 'logged_in' && auth.user.role === 'cardless_voter';
}
