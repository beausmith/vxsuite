import { fakeWritable } from '@votingworks/test-utils';
import { JSDOM } from 'jsdom';
import {
  buildSchema,
  camelize,
  extractDocumentation,
  getTypeScriptTypeRef,
  getZodSchemaRef,
} from '.';

test('empty', () => {
  const out = fakeWritable();

  buildSchema(
    `<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
</xsd:schema>
`,
    out
  );

  expect(out.toString()).toMatchInlineSnapshot(`
    "// DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.

    /* eslint-disable */

    import { z } from 'zod';

    import { Iso8601Date } from '@votingworks/types';

    /**
     * Schema for xsd:datetime values.
     */
    export const DateTimeSchema = Iso8601Date;

    /**
     * Schema for xsd:date values.
     */
    export const DateSchema = Iso8601Date;

    "
  `);
});

test('enum type', () => {
  const out = fakeWritable();

  buildSchema(
    `<?xml version="1.0" encoding="UTF-8"?>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
      <xsd:simpleType name="YesNo">
        <xsd:annotation>
          <xsd:documentation>YesNo is a simple enumeration of the values "yes" and "no".</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
          <xsd:enumeration value="yes">
            <xsd:annotation>
              <xsd:documentation>Yes</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="no">
            <xsd:annotation>
              <xsd:documentation>No</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:schema>`,
    out
  );

  expect(out.toString()).toMatchInlineSnapshot(`
    "// DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.

    /* eslint-disable */

    import { z } from 'zod';

    import { Iso8601Date } from '@votingworks/types';

    /**
     * Schema for xsd:datetime values.
     */
    export const DateTimeSchema = Iso8601Date;

    /**
     * Schema for xsd:date values.
     */
    export const DateSchema = Iso8601Date;

    /**
     * YesNo is a simple enumeration of the values \\"yes\\" and \\"no\\".
     */
    export enum YesNo {
      /**
       * Yes
       */
      Yes = 'yes',

      /**
       * No
       */
      No = 'no',
    }

    /**
     * Schema for {@link YesNo}.
     */
    export const YesNoSchema = z.nativeEnum(YesNo);

    "
  `);
});

test('object type', () => {
  const out = fakeWritable();

  buildSchema(
    `<?xml version="1.0" encoding="UTF-8"?>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
      <xsd:complexType name="Address">
        <xsd:annotation>
          <xsd:documentation>An address.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
          <xsd:element name="street" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The street address.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="street2" type="xsd:string" minOccurs="0" maxOccurs="1" />
          <xsd:element name="city" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The city.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="state" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The state.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:complexType>
    </xsd:schema>`,
    out
  );

  expect(out.toString()).toMatchInlineSnapshot(`
    "// DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.

    /* eslint-disable */

    import { z } from 'zod';

    import { Iso8601Date } from '@votingworks/types';

    /**
     * Schema for xsd:datetime values.
     */
    export const DateTimeSchema = Iso8601Date;

    /**
     * Schema for xsd:date values.
     */
    export const DateSchema = Iso8601Date;

    /**
     * An address.
     */
    export interface Address {
      /**
       * The street address.
       */
      street: string;

      street2?: string;

      /**
       * The city.
       */
      city: string;

      /**
       * The state.
       */
      state: string;
    }

    /**
     * Schema for {@link Address}.
     */
    export const AddressSchema: z.ZodSchema<Address> = z.object({
      street: z.string(),
      street2: z.optional(z.string()),
      city: z.string(),
      state: z.string(),
    });

    "
  `);
});

test('object type property types', () => {
  const out = fakeWritable();

  buildSchema(
    `<?xml version="1.0" encoding="UTF-8"?>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
      <xsd:complexType name="AnObject">
        <xsd:sequence>
          <xsd:element name="aString" type="xsd:string"/>
          <xsd:element name="aBoolean" type="xsd:boolean"/>
          <xsd:element name="aDecimal" type="xsd:decimal"/>
          <xsd:element name="aDate" type="xsd:date"/>
          <xsd:element name="aDateTime" type="xsd:dateTime"/>
          <xsd:element name="zeroOrMoreStrings" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/>
          <xsd:element name="oneOrMoreStrings" type="xsd:string" minOccurs="1" maxOccurs="unbounded"/>
        </xsd:sequence>
      </xsd:complexType>
    </xsd:schema>`,
    out
  );

  expect(out.toString()).toMatchInlineSnapshot(`
    "// DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.

    /* eslint-disable */

    import { z } from 'zod';

    import { Iso8601Date } from '@votingworks/types';

    /**
     * Schema for xsd:datetime values.
     */
    export const DateTimeSchema = Iso8601Date;

    /**
     * Schema for xsd:date values.
     */
    export const DateSchema = Iso8601Date;

    export interface AnObject {
      aString: string;

      aBoolean: boolean;

      aDecimal: number;

      aDate: string;

      aDateTime: string;

      zeroOrMoreStrings: string[];

      oneOrMoreStrings: string[];
    }

    /**
     * Schema for {@link AnObject}.
     */
    export const AnObjectSchema: z.ZodSchema<AnObject> = z.object({
      aString: z.string(),
      aBoolean: z.boolean(),
      aDecimal: z.number(),
      aDate: DateSchema,
      aDateTime: DateTimeSchema,
      zeroOrMoreStrings: z.array(z.string()),
      oneOrMoreStrings: z.array(z.string()).nonempty(),
    });

    "
  `);
});

test('object type references', () => {
  const out = fakeWritable();

  buildSchema(
    `<?xml version="1.0" encoding="UTF-8"?>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
      <xsd:complexType name="AnObject">
        <xsd:sequence>
          <xsd:element name="aString" type="xsd:string"/>
        </xsd:sequence>
      </xsd:complexType>
      <xsd:complexType name="AnotherObject">
        <xsd:sequence>
          <xsd:element name="anObject" type="AnObject"/>
        </xsd:sequence>
      </xsd:complexType>
    </xsd:schema>`,
    out
  );

  expect(out.toString()).toMatchInlineSnapshot(`
    "// DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.

    /* eslint-disable */

    import { z } from 'zod';

    import { Iso8601Date } from '@votingworks/types';

    /**
     * Schema for xsd:datetime values.
     */
    export const DateTimeSchema = Iso8601Date;

    /**
     * Schema for xsd:date values.
     */
    export const DateSchema = Iso8601Date;

    export interface AnObject {
      aString: string;
    }

    /**
     * Schema for {@link AnObject}.
     */
    export const AnObjectSchema: z.ZodSchema<AnObject> = z.object({
      aString: z.string(),
    });

    export interface AnotherObject {
      anObject: AnObject;
    }

    /**
     * Schema for {@link AnotherObject}.
     */
    export const AnotherObjectSchema: z.ZodSchema<AnotherObject> = z.object({
      anObject: z.lazy(() => AnObjectSchema),
    });

    "
  `);
});

test('unknown xsd element type', () => {
  const out = fakeWritable();

  buildSchema(
    `<?xml version="1.0" encoding="UTF-8"?>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
      <xsd:somethingElse>
      </xsd:somethingElse>
    </xsd:schema>`,
    out
  );

  expect(out.toString()).toMatchInlineSnapshot(`
    "// DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.

    /* eslint-disable */

    import { z } from 'zod';

    import { Iso8601Date } from '@votingworks/types';

    /**
     * Schema for xsd:datetime values.
     */
    export const DateTimeSchema = Iso8601Date;

    /**
     * Schema for xsd:date values.
     */
    export const DateSchema = Iso8601Date;

    "
  `);
});

test('unknown xsd property type', () => {
  expect(() =>
    getZodSchemaRef('xsd:notAType')
  ).toThrowErrorMatchingInlineSnapshot(`"Unsupported xsd type: xsd:notAType"`);

  expect(() =>
    getTypeScriptTypeRef('xsd:notAType')
  ).toThrowErrorMatchingInlineSnapshot(`"Unsupported xsd type: xsd:notAType"`);
});

test('extract documentation with documentation present', () => {
  const dom = new JSDOM(
    `<?xml version="1.0" encoding="UTF-8"?>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
      <xsd:annotation>
        <xsd:documentation>Here is documentation</xsd:documentation>
      </xsd:annotation>
    </xsd:schema>`,
    { contentType: 'text/xml' }
  );

  const schema = dom.window.document.documentElement;
  expect(extractDocumentation(schema)).toEqual('Here is documentation');
});

test('extract documentation with no documentation element', () => {
  const dom = new JSDOM(
    `<?xml version="1.0" encoding="UTF-8"?>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    </xsd:schema>`,
    { contentType: 'text/xml' }
  );

  const schema = dom.window.document.documentElement;
  expect(extractDocumentation(schema)).toBeUndefined();
});

test('camelize', () => {
  expect(camelize('foo')).toBe('Foo');
  expect(camelize('foo-bar')).toBe('FooBar');
  expect(camelize('abc-123')).toBe('Abc123');
});
