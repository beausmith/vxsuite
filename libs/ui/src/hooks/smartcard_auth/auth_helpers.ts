import {
  AdminCardData,
  AnyCardDataSchema,
  CardProgramming,
  CardStorage,
  DippedSmartcardAuth,
  err,
  InsertedSmartcardAuth,
  ok,
  Optional,
  PollworkerCardData,
  safeParseJson,
  SuperadminCardData,
  User,
  wrapException,
} from '@votingworks/types';
import { Card, CardSummaryReady, throwIllegalValue } from '@votingworks/utils';
import { LogEventId, Logger } from '@votingworks/logging';

import { Lock } from '../use_lock';

export const CARD_POLLING_INTERVAL = 100;

export function parseUserFromCardSummary(
  cardSummary: CardSummaryReady
): Optional<User> {
  if (!cardSummary.shortValue) return undefined;
  const cardData = safeParseJson(
    cardSummary.shortValue,
    AnyCardDataSchema
  ).ok();
  if (!cardData) return undefined;
  switch (cardData.t) {
    case 'superadmin':
      return { role: 'superadmin' };
    case 'admin':
      return { role: 'admin', electionHash: cardData.h, passcode: cardData.p };
    case 'pollworker':
      return { role: 'pollworker', electionHash: cardData.h };
    case 'voter':
      return {
        role: 'voter',
        createdAt: cardData.c,
        ballotStyleId: cardData.bs,
        precinctId: cardData.pr,
        voidedAt: cardData.uz,
        ballotPrintedAt: cardData.bp,
        updatedAt: cardData.u,
        markMachineId: cardData.m,
      };
    /* istanbul ignore next - compile time check for completeness */
    default:
      throwIllegalValue(cardData, 't');
  }
}

export function buildCardStorage(
  cardSummary: CardSummaryReady,
  cardApi: Card,
  cardWriteLock: Lock
): CardStorage {
  return {
    hasStoredData: !!cardSummary.longValueExists,

    readStoredObject: async (schema) => cardApi.readLongObject(schema),

    readStoredString: async () => {
      try {
        const value = await cardApi.readLongString();
        return ok(value || undefined);
      } catch (error) {
        return wrapException(error);
      }
    },

    readStoredUint8Array: async () => {
      try {
        const value = await cardApi.readLongUint8Array();
        return ok(value && value.length > 0 ? value : undefined);
      } catch (error) {
        return wrapException(error);
      }
    },

    writeStoredData: async (value) => {
      if (!cardWriteLock.lock()) {
        return err(new Error('Card write in progress'));
      }
      try {
        if (value instanceof Uint8Array) {
          await cardApi.writeLongUint8Array(value);
        } else {
          await cardApi.writeLongObject(value);
        }
        return ok();
      } catch (error) {
        return wrapException(error);
      } finally {
        cardWriteLock.unlock();
      }
    },

    clearStoredData: async () => {
      if (!cardWriteLock.lock()) {
        return err(new Error('Card write in progress'));
      }
      try {
        await cardApi.writeLongUint8Array(Uint8Array.of());
        return ok();
      } catch (error) {
        return wrapException(error);
      } finally {
        cardWriteLock.unlock();
      }
    },
  };
}

/**
 * Builds an interface for smartcard programming, meant to augment the base smartcard interface
 * generated by buildCardStorage
 */
export function buildCardProgramming(
  cardSummary: CardSummaryReady,
  cardApi: Card,
  cardWriteLock: Lock,
  logger?: Logger
): CardProgramming {
  return {
    programmedUser: parseUserFromCardSummary(cardSummary),
    programUser: async (userData) => {
      const { role } = userData;
      if (logger) {
        await logger.log(LogEventId.SmartcardProgramInit, 'superadmin', {
          message: `Programming ${role} smartcard...`,
          programmedUserRole: role,
        });
      }
      try {
        if (!cardWriteLock.lock()) {
          throw new Error('Card write in progress');
        }
        switch (role) {
          case 'superadmin': {
            const cardData: SuperadminCardData = {
              t: 'superadmin',
            };
            await cardApi.overrideWriteProtection();
            await cardApi.writeShortValue(JSON.stringify(cardData));
            break;
          }
          case 'admin': {
            const cardData: AdminCardData = {
              t: 'admin',
              h: userData.electionHash,
              p: userData.passcode,
            };
            await cardApi.overrideWriteProtection();
            await cardApi.writeShortAndLongValues({
              shortValue: JSON.stringify(cardData),
              longValue: userData.electionData,
            });
            break;
          }
          case 'pollworker': {
            const cardData: PollworkerCardData = {
              t: 'pollworker',
              h: userData.electionHash,
            };
            await cardApi.overrideWriteProtection();
            await cardApi.writeShortValue(JSON.stringify(cardData));
            break;
          }
          /* istanbul ignore next: Compile-time check for completeness */
          default:
            throwIllegalValue(role);
        }
        if (logger) {
          await logger.log(LogEventId.SmartcardProgramComplete, 'superadmin', {
            disposition: 'success',
            message: `Successfully programmed ${role} smartcard.`,
            programmedUserRole: role,
          });
        }
        return ok();
      } catch (error) {
        if (logger) {
          await logger.log(LogEventId.SmartcardProgramComplete, 'superadmin', {
            disposition: 'failure',
            message: `Error programming ${role} smartcard.`,
            programmedUserRole: role,
          });
        }
        return wrapException(error);
      } finally {
        cardWriteLock.unlock();
      }
    },
    unprogramUser: async () => {
      const programmedUser = parseUserFromCardSummary(cardSummary);
      if (!programmedUser) {
        // Short-circuit if the card is already unprogrammed
        return ok();
      }
      const programmedUserRole = programmedUser.role;
      if (logger) {
        await logger.log(LogEventId.SmartcardUnprogramInit, 'superadmin', {
          message: `Unprogramming ${programmedUserRole} smartcard...`,
          programmedUserRole,
        });
      }
      try {
        if (!cardWriteLock.lock()) {
          throw new Error('Card write in progress');
        }
        await cardApi.overrideWriteProtection();
        await cardApi.writeShortAndLongValues({
          shortValue: '',
          longValue: '',
        });
        if (logger) {
          await logger.log(
            LogEventId.SmartcardUnprogramComplete,
            'superadmin',
            {
              disposition: 'success',
              message: `Successfully unprogrammed ${programmedUserRole} smartcard.`,
              previousProgrammedUserRole: programmedUserRole,
            }
          );
        }
        return ok();
      } catch (error) {
        if (logger) {
          await logger.log(
            LogEventId.SmartcardUnprogramComplete,
            'superadmin',
            {
              disposition: 'failure',
              message: `Error unprogramming ${programmedUserRole} smartcard.`,
              programmedUserRole,
            }
          );
        }
        return wrapException(error);
      } finally {
        cardWriteLock.unlock();
      }
    },
  };
}

// Below, we define some useful type guards for checking who's logged in
// We use function overloads to make them work with either Inserted or Dipped auth

export function isSuperadminAuth(
  auth: InsertedSmartcardAuth.Auth
): auth is InsertedSmartcardAuth.SuperadminLoggedIn;
export function isSuperadminAuth(
  auth: DippedSmartcardAuth.Auth
): auth is DippedSmartcardAuth.SuperadminLoggedIn;
export function isSuperadminAuth(
  auth: InsertedSmartcardAuth.Auth | DippedSmartcardAuth.Auth
): boolean {
  return auth.status === 'logged_in' && auth.user.role === 'superadmin';
}

export function isAdminAuth(
  auth: InsertedSmartcardAuth.Auth
): auth is InsertedSmartcardAuth.AdminLoggedIn;
export function isAdminAuth(
  auth: DippedSmartcardAuth.Auth
): auth is DippedSmartcardAuth.AdminLoggedIn;
export function isAdminAuth(
  auth: InsertedSmartcardAuth.Auth | DippedSmartcardAuth.Auth
): boolean {
  return auth.status === 'logged_in' && auth.user.role === 'admin';
}

export function isPollworkerAuth(
  auth: InsertedSmartcardAuth.Auth
): auth is InsertedSmartcardAuth.PollworkerLoggedIn {
  return auth.status === 'logged_in' && auth.user.role === 'pollworker';
}

export function isVoterAuth(
  auth: InsertedSmartcardAuth.Auth
): auth is InsertedSmartcardAuth.VoterLoggedIn {
  return auth.status === 'logged_in' && auth.user.role === 'voter';
}

export function isCardlessVoterAuth(
  auth: InsertedSmartcardAuth.Auth
): auth is InsertedSmartcardAuth.CardlessVoterLoggedIn {
  return auth.status === 'logged_in' && auth.user.role === 'cardless_voter';
}
